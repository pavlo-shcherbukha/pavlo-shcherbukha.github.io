---
layout: post
title: "Learning RabbitMQ"
date: 2024-11-15 10:00:01
categories: [Python, Flask, RabbitMQ]
permalink: posts/2024-11-15/rabbit-mq/
published: true
---

<!-- TOC BEGIN -->
- [1. Постановка проблеми](#p1)
- [2. Gро коцепцію продукта в моєму зрозумінні](#p2)
- [3. Опис тестового стенду для вичення API-Connect](#p3)
- [4. Розробка бібліотеки API  в API-COnnect](#p4)
- [4.1. Загальний огляда](#p4.1)
- [4.2. Особливості підготовки формалізованного опису API  в форматі openapi-3.0](#p4.2)
- [4.3. Особливості налаштування GateWay](#p4.3)
- [4.4. Тестування API](#p4.4)





<!-- TOC END -->

## <a name="p1">1. Постановка проблеми</a>
 
В процесі роботи вникла необхідність в розробці фонових процесів, що обробляють великі об'єми бінарних даних. По чистому http прокачування таких об'ємів даних завдання не просте і, взагалі то, не надійне. Тому і впав вибір на використання черг. Раніше приходилося використовувати черги Redis. Але, для великих об'ємів даних (типу image) використання redis не прийнятне.
Є в мене досвід і з використання IBM MQ.  Але, там теж є особливості, а саме: 
- потребує ліцензування;
- дуже "важка" (рідний клієнт IBM MQ  десь під 1 ГБ важить);
- не має "нормальних" клієнтів для Node.js, Python, JAVA;
Клієнти заявлені, але працюють вони препротивно і не надійно

А якщо почитати про Rabbit MQ  то вона практично покриває своєю функціональнісью всі рекламні тексти протипу: "Чому треба використовувати IBM MQ". А на фоні відсутності нормлаьних клієнтів до IBM MQ  то вибір точно на користь Rabbit.  Ну, а якщо ж мені знадобиться інтеграція з IBM MQ,  то я постараюсть використати існуючий в IBM MQ  протокол AMQP.

На  цій позитвній ноті я зайнявся вивченням Rabbit MQ  на  базі Python

## <a name="p2">2. Перелік корисних лінків</a>

- [Rabbit tutorials](https://www.rabbitmq.com/tutorials)
Це основна документація по Rabbit MQ

- [habre](https://habr.com/ru/articles/434510/)

Тут коротенький огляд про клієнти python для RabbitMq

- [python pika](https://pika.readthedocs.io/en/stable/), [pypi pika](https://pypi.org/project/pika/) 

Документація на клієнт rabbit MQ для Python, **бібліотека pika**

- [Getting Started with RabbitMQ and Python: A Practical Guide. Docker compose](https://dev.to/felipepaz/getting-started-with-rabbitmq-and-python-a-practical-guide-57fi)

Тут цікавий блог, про використання RabbitMQ and Python з практичними рекомендаціями

- [Docker RabbitMQ](https://hub.docker.com/_/rabbitmq/)

Посилання на Docker container для запуску rbbit MQ на робочій станції

 
### <a name="p3">3. Прототип:  Розподілення завдань між обробниками</a>


```mermaid
    C4Context
      title Архітектура прототипу
      
        Person(customerA, "User A", "Завантажувач зображень")
        Person(customerB, "User B", "Перегляд зображень")

        System(WebUI1, "WebUI Image uploader", "Завантаження  зображень")
        System(WebUI2, "WebU2 Image display", "Перегляд зображень")
        
        Enterprise_Boundary(b1, "Cbcntvb") {
          System(WebApp, "Python Flask WebApp", "Завантаження та вивантеження зображень")
          SystemQueue( TestQueue, "test_queue", "Черга зображень  на обробку")
          System(Worker1, "Python Image processor, "Обробка зображень бібліотекоб CV2")
          SystemQueue( TestQueue, "test_queue", "Черга зображень  на обробку")
          SystemQueue(TestDbWrt, "test_dbwrt", "Черга оброблених зображень")
          System(Worker2, "Python Database Writer", "Запис трансформованих зображень в базу даних")
          SystemDb(ImageDB, "CouchDB", "База даних оброблених зображень")

          System(RabbitMQ, "Rabbit MQ", "Сервер RabbitMQ")


        }

      Rel(customerA, WebUI1, "Завантаження зображення")
      Rel(customerB, WebUI2, "Перегляд оброблених зображень")
      BiRel(WebUI1, WebApp , "API завантаженя зображення")
      BiRel(WebUI2, WebApp , "API отримання зображення")
      Rel(WebApp, TestQueue, "Публікація зображення в чергу на обробку")
      Rel(TestQueue, Worker1, "Читання черги зображень на обробку")
      Rel(Worker1, TestDbWrt, "Публікація в чергу оброблених зображень")
      Rel(TestDbWrt, Worker2 , "Читанн черги оброблених зображень для запису в базу даних")
      Rel(Worker2, ImageDB, "Запис оброблених зображень")
      Rel(ImageDB, WebApp, "Читання оброблених зображень з БД")


      UpdateLayoutConfig($c4ShapeInRow="2", $c4BoundaryInRow="1")


```

Бізнесова модель прототипу полягає в наступному. 
1. Через Web додаток користувач завантажує зображення в систему. Flask Webervice приймає масив байт зображення та публікує зображення в чергу **test_queue** з специфічними заголовками. В заголовках вказується тип медіаконтенту та назва файлу. 

2. Фоновий обробник **Python image processor** "слухає" чергу **test_queue** і, прочитавше повідомлення, за допомогою бібліотеки обробки зображень [ opencv, CV2](https://opencv.org/) перетворює зображення до формату .png та робить його чорно-білим і публікує оброблене зображення в чергу **test_dbwrt**  для запису зображення в базу даних.

3. Фоновий обробник запису зображень в базу даних **Python Database Writer**  слухає чергу  **test_dbwrt**. Прочитавши повідомлення з  черги, обробник з заголовків повідомлення черги формує  структуру документа - метадані зображення, а зображення записує, як attachment  до документу бази даних.

4. Через Web додаток користувач  отримує список оброблених зображень з бази даних і має можливість прочитати зображення з БД і переглянути йогог на web  сторінці.


По суті, це прототип для шаблону проектування [work-queues](https://www.rabbitmq.com/tutorials#2-work-queues)

<kbd><img src="/assets/img/posts/2024-12-15-rabbit-mq/doc/img-01.png" /></kbd>
<p style="text-align: center;"><a name="img-01">img-01</a></p>

Критика:
Це не ідеальне рішення. По факту зображення можна зразу писати в базу даних, а в черги обробникам відправляти тільки метадані. Але була ціль саме перевірити, як обробляти в чергах повідомлення з бінарними об'єктами.


## <a name="p4">4. Особливості програмного коду прототипу</a>

Програмний код прототипу знаходиться в репозиторії: [learnamqp](https://github.com/pavlo-shcherbukha/learnamqp).

1. **Python Flask WebApp** знаходиться в каталозі **./sender_web**.
2. **Python Image processor** знаходиться в каталозі **./receiver_web**. Запускається з "${workspaceFolder}/receiver_weber.py"
3. **Python Database Writer** знаходиться в каталозі **./writer_web**. Запускається "${workspaceFolder}/writer_weber.py".


Всі додатки в комплексі запускаються за допомогою Docker Composer: [docker-compose-websender.yaml](https://github.com/pavlo-shcherbukha/learnamqp/blob/main/docker-compose-websender.yaml). 

Конфігураційні файли Docker Composer: - [docker-compose-couch.yaml](https://github.com/pavlo-shcherbukha/learnamqp/blob/main/docker-compose-couch.yaml); 
- [docker-compose-rabbit.yaml](https://github.com/pavlo-shcherbukha/learnamqp/blob/main/docker-compose-rabbit.yaml) - використовуються для запуску тільки couchdb чи rabbit mq.

Необхідні бібіліотеки, що є  спільні для всіх  додатків прописані в файлі [requirements.txt](https://github.com/pavlo-shcherbukha/learnamqp/blob/main/requirements.txt). За виключеннм бібліотеки обробки зображень, тому, що вони досить великі і займають багато часу при інсталяції. Тому в [docker-receive-web](https://github.com/pavlo-shcherbukha/learnamqp/blob/main/docker-receive-web) установка цих бібліотек прописана окремо:

```bash
# Install the dependencies

RUN python3.9 -m pip install --upgrade pip

RUN /usr/libexec/s2i/assemble
#RUN pip3 install opencv-python
RUN pip3 install opencv-contrib-python
RUN pip3 install numpy
EXPOSE 8080

# Remote debug run: packages
# RUN pip install ptvsd debugpy
# Remote debug run: Keeps Python from generating .pyc files in the container

```





