---
layout: post
title: "Python Flask app with TLS on openshift"
date: 2023-03-30 10:00:01
categories: [Python, Flask, openshift]
permalink: posts/2023-03-30/py_flask_app_on_openshift_tls/
published: true
---

<!-- TOC BEGIN -->

<!-- TOC END -->

## <a name="p-1">Постановка проблеми</a>

При розробці сучасних багатосервісних систем частно виникає необхідність захисту даних на трансопортному рівні. Тому це було першопричиною для того щоб розібратися в цьому, а потім написати цей блог. А в процесі вивчення тми виникли додаткові аргументи в цій сфері.

На приклад маємо таку архітектуру компонентів:

<kbd><img src="/assets/img/posts/2023-03-30-py-flask-openshift-tls/doc/pic-02.png" /></kbd>
<p style="text-align: center;"><a name="pic-02">pic-02</a></p>

Синіми та чорними лініями показана дозволена взаємодія клієнта (сині) та сервісів (чорні). Червона лінія показує  заборонену взаємодію. Може виникнути питання чому ця дія заборонена. На компоненті RestApi скоріше за все немає аутентифікації користувача. Більш того, backend сервіси можуть організовувати с RestApi сервісом взаємодію, по специфічному шаблону взаємодії типу: webpooling чи webhook -  для того щоб не перевантажити сервіс, чи отримати дані послідовно, порціями, а потім користувачу віддати вже все. При чому, customer  це не завжди вреднючий користувач. Просто він користується такми фронтом, де програміст зробив "покращення", тому що так швидше.


Тут стає питання, як забезпечити тількт дозволені комунікації між сервісами. Більш того, За звичай існує 2 середовища: продуктивне та тестове. І, потрібно максимально ізолювати їх між собою. І не завжди мереживні технології дозволяють це зробити. Тому, одним із швидих  методів дозволити тільки очевидні комунікації між сервісами може забезпечити використання TLS  протоколів з різними типами атворизації.



Можна побудувати для захисту таку, архітектуру для приклау.

<kbd><img src="/assets/img/posts/2023-03-30-py-flask-openshift-tls/doc/pic-03.png" /></kbd>
<p style="text-align: center;"><a name="pic-03">pic-03</a></p>

Це не єдиний шлях але можливий.  Тому активно прийшлось вивчити як  виконуати розроку та взгалі побудувати процесс розроки та суппорту при масовому використанні TLS. За лінком:  [tls-self-sign-certs Набрі кроків для генерації самопідписних TLS сертифікатів](https://github.com/pavlo-shcherbukha/tls-self-sign-certs#tls-self-sign-certs-%D0%BD%D0%B0%D0%B1%D1%80%D1%96-%D0%BA%D1%80%D0%BE%D0%BA%D1%96%D0%B2-%D0%B4%D0%BB%D1%8F-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%86%D1%96%D1%97-%D1%81%D0%B0%D0%BC%D0%BE%D0%BF%D1%96%D0%B4%D0%BF%D0%B8%D1%81%D0%BD%D0%B8%D1%85-tls--%D1%81%D0%B5%D1%80%D1%82%D0%B8%D1%84%D1%96%D0%BA%D0%B0%D1%82%D1%96%D0%B2) описаний простий набір кроків як розробнику швидко строрити набір tls сертифікатів  та демка на Node.js express  як перевірити їх працездатність. Ці кроки уже кілька разів використовував, коли виникала необхідність змоделювати роботу інших сервісів. Виявилося дуже зручно.

Але, основним завданням у мене було  розібратися, як запустити Python flask сервіси за tls  протоколом на Openshift. Найбльш коротко і лаконічно  описано  про можливості  використання транспортного захисту в роутерах openshift за лінком [Secure your-microservices with RedHat OpenShft Routes](https://masamh.gitbook.io/secure-your-app-on-rhos/). Ось [pic-01](pic-01)

<kbd><img src="/assets/img/posts/2023-03-30-py-flask-openshift-tls/doc/pic-01.png" /></kbd>
<p style="text-align: center;"><a name="pic-01">pic-01</a></p>


показані  комбінації  можливих варіантів захисту.

1. Без захисту, по чистому http. Трафіук взагалі ніяк не шифрується
2. В цьму варіанті, трафік шифрується до  самого роутера OpenShift,  а далі використовується чистий http.
3. До роутера трафік захищений одним набороб сертифікатів, а після роутера і до самого сервісу трафік шифрується уже іншим набором.
4.  Роутер просто пропускає через себе TLS  трафік, і розшифровується він уже на самому сервісі.


Щоб якось перевірити це та  зрозуміти як це робити розроблений приклад за лінком: [tls-pyflask-srvc Запуск Python-Flask application за https](https://github.com/pavlo-shcherbukha/tls-pyflask-srvc#tls-pyflask-srvc-%D0%B7%D0%B0%D0%BF%D1%83%D1%81%D0%BA-python-flask-application-%D0%B7%D0%B0-https). В цьому репозиторіх, як раз і використані підходи 2 та 4 з [pic-01](pic-01).









